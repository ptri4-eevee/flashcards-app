[{
  "id": "1",
  "name": "Sliding Window",
  "description": "The Sliding Window pattern is used to perform a required operation on a specific window size of a given array or linked list, such as finding the longest subarray containing all 1s. Sliding Windows start from the 1st element and keep shifting right by one element and adjust the length of the window according to the problem that you are solving. In some cases, the window size remains constant and in other cases the sizes grows or shrinks. Following are some ways you can identify that the given problem might require a sliding window: The problem input is a linear data structure such as a linked list, array, or string; You’re asked to find the longest/shortest substring, subarray, or a desired value.",
  "challengeQuestion": "Given an array of positive numbers and a positive number k, find the maximum sum of any contiguous subarray of size k.",
  "challengeAnswer": "To calculate the sum of a contiguous subarray, we can utilize the sum of the previous subarray. Consider each subarray as a sliding window of size k. To calculat the sum of the next subarray, slide the window ahead by one element. Slide the window forward and claculate the sum of the new position of the sliding window. Subtract the element going out of the sliding window, ie subtract the first element of the window. Add the new element getting included in the sliding window, ie the element coing right after the end of the window. This approach will save us from re-calculating the sum of the overlapping part of the sliding window."
},
  {
    "id": "2",
    "name": "Two Pointers or Iterators",
    "description": "Two Pointers is a pattern where two pointers iterate through the data structure in tandem until one or both of the pointers hit a certain condition.Two Pointers is often useful when searching pairs in a sorted array or linked list; for example, when you have to compare each element of an array to its other elements. Two pointers are needed because with just pointer, you would have to continually loop back through the array to find the answer. This back and forth with a single iterator is inefficient for time and space complexity — a concept referred to as asymptotic analysis. While the brute force or naive solution with 1 pointer would work, it will produce something along the lines of O(n²). In many cases, two pointers can help you find a solution with better space or runtime complexity.",
    "challengeQuestion": "Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target. Write a function to return the indices of the two numbers (i.e. the pair) such that they add up to the given target.",
    "challengeAnswer": "We can follow the Two Pointers approach. We will start with one pointer pointing to the beginning of the array and another pointing at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do, we have found our pair. Otherwise, we will do one of two things. otherwise, we will do one of two things: 1. If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer. 2. If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer."
  },
  {
    "id": "14",
    "name": "Merge Intervals",
    "description": "The Merge Intervals pattern is an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, you either need to find overlapping intervals or merge intervals if they overlap. The pattern works like this: Given two intervals (a and b), there will be six different ways the two intervals can relate to each other: Understanding and recognizing these six cases will help you help you solve a wide range of problems from inserting intervals to optimizing interval merges. How do you identify when to use the Merge Intervals pattern? If you are asked to produce a list with only mutually exclusive intervals; If you hear the term overlapping intervals.",
    "challengeQuestion": "Given a list of intervals, merge all the overlapping intervals to produce a list that has only mutually exclusive intervals.",
    "challengeAnswer": "Take the example of two intervals (a and b) such that a.start <= b.start. Scenario 1: a and b do not overlap. Scenario 2: some part of b overlaps with a. Scenario 3: a fully overlaps b. Scenario 4: b fully overlaps a but both have the same start time. Our goal is to merge the intervals whenever they overlap. Sort the intervals on the start time to ensure a.start <= b.start. If a overlaps b (i.e. b.start <= a.end), we need to merge them into a new interval c. We will keep repeating the above two steps to merge c with the next interval if it overlaps with c."
  }
]